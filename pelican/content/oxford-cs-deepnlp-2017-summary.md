Title: 「深層学習と自然言語処理」オックスフォード大/DeepMind 講義まとめ（用語集付き）
Date: 2018-02-08 00:00
Category: Deep Learning
slug: oxford-cs-deepnlp-2017-summary

![「深層学習と自然言語処理」オックスフォード大/DeepMind 講義](images/oxford-deepnlp-lectures.png)

オックスフォード大の「深層学習と自然言語処理」([Oxford Deep NLP 2017 course](https://github.com/oxford-cs-deepnlp-2017/lectures))の講義メモです。

講義ビデオ、スライド、講義の詳細等については、[講義の公式ページ](https://github.com/oxford-cs-deepnlp-2017/lectures)を参照してください。

## 目次

- [講義1a: 導入 (Phil Blunsom)](#lecture1a)
- [講義1b: 深層ニューラルネットは友だち (Wang Ling)](#lecture1b)
- [講義2a: 単語レベルの意味 (Ed Grefenstette)](#lecture2a)
- [講義2b: 実習の概要 (Chris Dyer)](#lecture2b)
- [講義3: 言語モデルとRNN パート1 (Phil Blunsom)](#lecture3)
- [講義4: 言語モデルとRNN パート2 (Phil Blunsom)](#lecture4)
- [講義5: テキスト分類 (Karl Moritz Hermann)](#lecture5)
- [講義6: Nvidia の GPU を使った深層学習 (eremy Appleyard)](#lecture7)
- [講義7: 条件付き言語モデリング (Chris Dyer)](#lecture7)
- [講義8: アテンションを使った言語生成 (Chris Dyer)](#lecture8)
- [講義9: 音声認識 (Andrew Senior)](#lecture9)
- [講義10: 音声合成 (Andrew Senior)](#lecture10)
- [講義11: 質問応答 (Karl Moritz Hermann)](#lecture11)
- [講義12: 記憶 (Ed Grefenstette)](#lecture12)
- [講義13: ニューラルネットにおける言語知識 (Chris Dyer)](#lecture13)

<hr/>

<a name="lecture1a"></a>
## 講義1a: 導入

講師：Phil Blunsom (オックスフォード大 / DeepMind)

- はじめに
    - AI (人工知能) といえば自然言語
    - 言語は、コミュニケーションだけではなく、概念を表現するために使われる
    - どうやって人間が言語を学習するかはまだよく分かっていない

- 教科書
    - 最新の研究を扱うため、教科書を使わない。ただし、必要に応じて以下を参考：
        - 深層学習: Goodfellow, Bengio, Courville: [Deep Learning](http://www.deeplearningbook.org/)
        - 機械学習: [Murphy 本](https://mitpress.mit.edu/books/machine-learning-0) と [Bishop 本](http://www.springer.com/us/book/9780387310732)

- 前提知識
    - 数学 (線形代数, 微分積分, 確率)
    - 機械学習 (評価; 過学習, 一般化, 正則化; ニューラルネットワークの基礎)
    - プログラミング (言語やフレームワークは問わない)
    - 自然言語処理 (NLP) や計算機言語学 (CL) の包括的なコースでははない

- タスク
    - 言語理解
        - CNN のニュース記事を与え、質問に答える。
    - 変換 (transduction) タスク。系列から系列への変換。
        - 音声認識：音声 → テキスト
        - 機械翻訳：テキスト(言語X) → テキスト(言語Y)
        - 音声合成：テキスト → 音声
    - 画像理解
        - 「この男性の視力は 2.0 か？」
            - 視力とメガネに関する知識を持っていないければいけない

- 言語構造
    - 多義性: "I saw her duck" (注: "duck"は「アヒル」という意味と「身をかがめる」という意味がある)
    - 慣用句: "kick the bucket" →　「死ぬ」
    - 照応: ボールは箱の中に入らなかった。それは[大きすぎる/小さすぎる]からだ。
        - 「それ」は箱か、ボールか。

| 英語              | 日本語             |
|-------------------|--------------------|
| compelling       | 人を引きつける       |
| prerequisite     | 前提知識           |
| comprehensive    | 包括的な            |
| 20/20 vision     | （日本での）視力 1.0  |
| duck (a.)        | アヒル              |
| duck (v.)        | しゃがむ            |
| kick the bucket  | 死ぬ               |

<hr/>

<a name="lecture1b"></a>
## 講義1b: 深層ニューラルネットは友だち

講師：Wang Ling (DeepMind)

_パート1_

- 数字
- 変数
- 演算子
- 関数 (入力, 出力)
    - 翻訳, 囲碁の手の推定, 画像分類もある種の関数

- 関数をどう推定するか
    - パラメータを使ってモデル化し、入力と出力からパラメータを推定。どう推定するか？
    - パラメータの「仮説」を立て、そのパラメータを使った出力と実際の出力とを比べる。
    - 仮説の「良さ」  →  損失関数によって定義  (例: 二乗損失)

- 最適化
    - 損失関数を最小化する
    - 単純な最適化：損失関数が下がる方向に、現在のパラメータを 1 ずつ動かしていく
    - 最適解を見つけられるとは限らない。「検索問題」と呼ばれる。

- 最適化の改善
    - ステップサイズを小さくする (例: 1 の代わりに 0.1 ずつ動かす)
    - ステップサイズを少しずつ小さくしていく

- このアプローチを画像分類に適用すると？
    - 画像全体が入力。1ピクセル = 1変数
    - モデルが大きすぎる
    - サンプル数が多すぎる

- 勾配！
    - パラメータを動かすベクトルを仮定し、移動した距離あたりの損失の減少幅を仮定 → limit → 損失関数の微分!
    - コスト関数自体の代わりに、微分を計算すれば良い

- 最急降下法
    - 現在のパラメータから、r = 損失関数の微分（単位距離あたりの損失減少）を計算
    - r * a (学習率)

_パート2 - 深層学習入門_

- 現実のモデルは非線形
    - 例：２つの線形モデルの組み合わせ　あるしきい値 (例: x = 6) から線形モデルが切り替わる
    - 一つの線形モデルでは学習が足りない (underfitting)

- モデルの組み合わせ
    - シグモイド関数 をモデル重みに使う y = (w1 x + b1) s1 + (w2 x + b2) s2
    - s = σ(wx + b)
    - wを大きくするとほぼステップ関数になる

- 多層パーセプトロン
    - 例：３つの線形モデルの組み合わせは？「not s1 and not s3」をどう表現する？
    - 最初のレイヤーは境界条件を学習
    - 次のレイヤーは範囲 (論理和や論理積) を学習、etc.
    - ３層を使うと XOR を学習できる → 十分の層とパラメータがあれば、任意の関数を近似できる

- 未学習 (underfitting)：モデルの表現力が（データの複雑さに対して）低すぎる
- 過学習 (overfitting)：モデルの表現力が高すぎる
    - データ量が増える → 過学習のリスクが下がる
    - 正則化 → モデルの複雑さに対するペナルティ → 過学習のリスクが下がる

- 離散値の扱い方
    - ルックアップ・テーブルを使う
    - 連続値の集合で、離散値を表現 → 埋め込み(embedding)
    - 出力 logit の集合を softmax で確率分布に変換

<hr/>

<a name="lecture2a"></a>
## 講義2a: 単語レベルの意味

講師: Ed Grefenstette (DeepMind)

単語をどう表現するか？

- 自然言語のテキスト：離散的な記号の系列
- 単純な表現：one-hot ベクトル
- 単語ベクトル

問題：スパース、単語同士が直交、意味を扱えない

- 分布類似度
    - 単語の意味を文脈によって表現　密なベクトル
    - 頻度ベース、予測ベース、タスクベースの３つの推定手法

- 頻度ベースの手法
    - 文脈（単語の左右の w 単語）における他の単語の出現頻度を数える -> ベクトル化
    - 単語同士の類似度をコサイン類似度によって計算  ベクトルの長さに依存しない
    - 素性の不平等さ  関連があるから頻度が高いのか、ただ単にその単語の頻度が高いのか  様々な正規化手法(例：TF-IDF, PMI)

- ニューラル埋め込みモデル
    - 単語-素性の行列を考える
    - one-hot ベクトルがあれば、掛け合わせると埋め込みが求まる

- ニューラル埋め込み
    - 単語 t に対して、コーパス内の文脈における素性（他の単語） c(t) の出現を数える
    - スコア関数を定義
    - 損失関数を、スコアのコーパス全体の和と定義
    - 損失関数を最小化
    - E が埋め込み

- 良いスコア関数とは？
    - 単語を埋め込みで表現（当然！）
    - t が c(t) によってどのぐらいうまく説明できるかを表現できる
    - ある単語が、（その他の単語よりも） 文脈をうまく表現できる
    - 微分可能

- C&W モデル (Collobert et al. 2011)
    - 埋め込み → 畳み込み → 多層パーセプトロン → スコア
    - 正しい単語のスコア - 間違った（無作為に選んだ単語で置き換えた分）スコアのヒンジ損失を最大化するように学習
    - 結果として、文脈の表現に関する情報も埋め込みにエンコーディングされるようになる

- CBoW (Mikolov et al. 2013)
    - 文脈から単語を予測
    - 文脈の単語を埋め込み表現、和を計算し、投影 → softmax
    - 線形で速い 以前は、計算量の高い softmax の代わりに negative sampling
    - 最近は softmax をそのまま計算

- Skip-gram (Mikolov et al. 2013)
    - 単語から文脈を予測
    - 単語の埋め込み → 投影 → softmax → 文脈単語の尤度
    - 速い！
    - 深層学習ではない！

- 両手法の比較
     - 頻度ベース vs ニューラル埋め込みモデル → 同じ考えを共有
     - word2vec == PMI (点相互情報量) 行列の分解 (Levy and Goldberg, 2014)

- ニューラル手法の長所
    - 実装・学習が容易
    - 高い並列度
    - 他の離散的な概念も使える (係り受けや品詞など)
    - 画像などの連続値文脈にも使える

- 内部的な評価
    - WordSim-333, SimLex-999, アナロジー (有名な例：queen = king - man + woman), 可視化

- 外部的な評価
    - 他のタスクの性能を上げるために使う

- タスクベース
    - 埋め込みをニューラルネットの入力として使う
    - 埋め込み（素性）もニューラルネットのパラメータの一部
    - 素性表現の学習
    - 単純な例
        - 文/文書分類 → Bag of Vectors （埋め込みベクトルの和） → 投影 → softmax
    - タスク依存の表現を学習（感情推定 → 肯定的・否定的な単語）
    - 単語の意味は、タスクに根付いている（タスクが意味を決める）

- 二言語素性 (Herman & Blunsom 2014)
    - 英語の文 e_i とドイツ語の文 g_i の類似度を最大化させる
    - 単純な和のかわりに、隣接する単語の間に非線形性を導入 (tanh)
    - 損失: 差を最小化  0 に縮退しないように、対訳と非対訳との間の差を最大化
    - 直感：対訳文は、高レベルの意味を共有する

- まとめ
    - タスクに特有の情報を学習できる  ただし、これが一般的な「意味」を学習している保証はない
        - マルチタスク目的関数である程度軽減できる。
    - 予備学習 (pre-trainig) して固定
        - 転移学習の一形態 タスク固有の訓練データが少なかったり、語彙のカバー率が小さかったりする時に有用
        - タスク固有の訓練データが大きいときには、一般性を犠牲にしても、埋め込みを学習するほうが良い

| 英語              | 日本語             |
|-------------------|--------------------|
| literature       | 過去の文献          |
| corrupt          | (データをわざと) 破損させる |
| intrinsic        | 内部的な            |
| extrinsic        | 外部的な            |
| salient          | 重要な             |

<hr/>

<a name="lecture2b"></a>
## 講義2b: 実習の概要

講師：Chris Dyer (DeepMind/CMU)

* ２種類の実習
    1. 入門実習
    2. 本実習

_実習1_

* 言語の「感知」と「表現」
    - 未知語
    - トークナイズ ("New York City" は１トークンか？３トークンか)
    - 大文字・小文字

* コーパス
    - ニュース記事 vs twitter
    - Heap's Law: コーパスのサイズが増えるにしたがって語彙のサイズも増える。
    - twitter は α が小さい（急激に）増える＋シングルトン（一度しか出現しない単語）が 70%

実習1では、表現学習を扱う

_本実習_

- テキスト分類 (e.g., スパムフィルタ)

- 自然言語生成 (NLG)
    - 言語モデリング
    - タイポ修正
    - 条件付き言語モデリング

- 自然言語理解
    - 翻訳、要約、チャットボット (+NLG)
    - 指示理解
    - 質問応答
    - 対話インターフェース

* 解析
    - トピックモデリング
    - 言語解析（例： 形態素解析、構文解析）

* データセット
    - 単一のデータセット TED Talks を使う
    - 単一のデータセットを色々な問題に変換するスキル → 機械学習では重要！
    - トピックラベル、タイトル、要約、ビデオ、ビデオとのアラインメント、翻訳

- 入門実習 -> TED Talks から単語埋め込みを学習
- 本実習
    - TED のラベルを予測
    - TED のラベルからトークを生成
    - TED のトーク翻訳器
    - TED のトークから要約を生成
    - ある部分を話すのにかかる時間を推定
    - 聴衆が笑ったかどうかを予測

- ツールキット
    - 自動微分 → 速度が重要＋間違いやすい
    - 静的 (TensorFlow, Theano)  pros: 計算グラフの最適化 cons: 演算が限られている
    - 動的 (DyNet, PyTorch)  pros: 何でも書ける  cons: 最適化がしにくい


| 英語              | 日本語             |
|-------------------|--------------------|
| practical         | 実習              |
| percept           | 知覚              |
| derivative        | 微分              |

<hr/>

<a name="lecture3"></a>
## 講義3: 言語モデルとRNN パート1

講師：Phil Blunsom

- 言語モデルとは
    - 単語の系列に確率を与える
    - 根本的な問題
        - 翻訳 → 構文や語順の解消
        - 音声認識 → 単語チョイスの曖昧性解消

- 歴史
    - 戦時の暗号理論 ドイツの Enigma 暗号の解読 → 「ドイツ語らしい」発話
    - 多くの自然言語処理タスクは、(条件付き)言語モデリングに帰着できる
        - 例: 翻訳、質問応答、対話

- 言語モデルの基本
    - 連鎖律 (Chain rule) を使って、同時分布を条件付き分布の積に分解
    - → 過去の履歴から、次の単語を予測する問題に変換
    - 大量のデータを簡単に取得できる
    - 自然言語を理解すること同様に難しい
        - 例：P(| There she built a ) → 非常に多くの可能性  難しい
        - 例: P(| Alice went to the beach. There she built a ) → "sand castle" "boat" etc.
        - there → the beach, she → Alice の照応関係を理解　かつ、セマンティクスを理解

- 評価
    - クロスエントロピー
        - テキストを言語モデルでエンコードする時に必要なビット数
    - Perplexity
        - 2 のクロスエントロピー乗
        - 各単語を見たときのモデルの「驚き度合い」
    - 時系列予測問題
        - 訓練データとは別のテストデータを使う

- データ
    - 少なくとも 10億単語は必要
    - PTB (Penn Treebank)
        - 小さい
        - 加工され過ぎ
    - Billon Word Corpus
        - 文をランダムに入れ替えて訓練・テストセットを作成
        - 「未来と過去を分離」「記事を分離」の２つの原則に反している
    - 上の２つとも欠陥があるので本当は使うべきではない
    - WikiText datasets
        - オススメ

- Nグラムモデル
    - マルコフ仮定
    - 最後の k - 1 個だけ見て次を予測。k次マルコフモデル
        - 多項分布を求めるのが簡単　スケーラブル
        - 例：トライグラム P(w3 | w1, w2) = count(w1, w2, w3) / count(w1, w2)

    - バックオフ
        - 最尤推定が良いとは限らない
        - "Oxford Primm's eater" → コーパス中におそらく一度も現れない
        - バイグラム確率と補間する
        - 単純な手法の一つ：線形補間バックオフ
        - 超巨大データがあれば、割と単純な手法でもうまくいく
        - 最も一般的な手法 Kneser-Ney


    - 言語モデルが難しい理由
        - ロングテール
        - どんなにコーパスを大きくしても未知語がある
        - ルールベースの人工知能がうまく行かない理由でもある
    - 長所
        - 速い
        - 評価が定数時間
        - 言語の実際の分布にマッチ
    - 短所
        - 長距離の依存関係を扱えない
        - dog/cat などの意味の似た分布や形態論を扱えない


- ニューラルNグラムモデル
    - トライグラムの場合
        - wn-2, wn-1 (one-hot ベクトル)
        - 直前２単語を入力として、wn の分布を softmax で出力する前向きニューラルネット
        - 出力の softmax 層は巨大！（入力は one-hot vector なのでそれほどでもない）

    - サンプリング
        - 直前２単語を入力、出力層の確率をもとに次の単語をサンプル、...
        - デコーディング(復号化)の基本
        - 確率をもとに最大のものを選ぶ

    - 学習
        - 実際の単語と、その単語の確率との間で損失関数(log probability)を定義
        - 逆伝搬
        - タイムステップごとに展開 (unrolling)
            - 逆伝播は木構造になる -> 複数CPU/GPU やクラスタ上で分散可能

    - 長所
        - 未知Nグラムへの一般化
        - 埋め込みにより、類義語をうまく扱える
        - Nグラムモデルより省メモリー（線形素性の場合）
    - 短所
        - nの値に従いパラメータ数が増加
        - 長距離の依存を扱えない
        - 言語の実際の分布を保証しない

- RNN 再帰型ニューラルネット
    - 無限の履歴
    - 直前の隠れ層 -> 次の隠れ層へのリンク

    - 逆伝播
        - 展開すると DAG(有向非巡回グラフ) になる
        - 通常通り誤差逆伝播できる (BPTT; Back Propagation Through Time) 時間軸上の逆伝播
        - ただし、各単語や隠れ層は独立に計算できない

    - Truncated Back Propagation Through Time
        - 逆伝搬を途中で分断する (前向き伝播の時は分断しない)

    - ミニバッチ化
        - BPTT を使うと、シークエンスがばらばらの長さ（ミニバッチを最長の長さに合わせなければならない）
        - TBPTT を使うと、各シークエンスが一定の長さに収まる (GPUで高速化しやすい)

    - 長所
        - 長距離の依存を扱える (翻訳等をするためには必須)
        - 履歴を隠れ層に圧縮, 依存の長さに応じてパラメータ数が増えない
    - 短所
        - 学習が難しい
        - 隠れ層のサイズの2乗に従ってメモリが増える
        - 言語の実際の分布を保証しない

- バイアス・バリアンスのトレードオフ
    - 例：文を覚えて数えるだけの言語モデル → 低バイアス、高バリアンス
    - Nグラムモデル：バイアス有り、低バリアンス
    - RNN: バイアスを減らす

| 英語              | 日本語             |
|-------------------|--------------------|
| utterance         | 発話              |
| inflate           | (数字を)実情以上に大きくする   |
| flawed            | 欠陥がある         |
| power law         | べき乗則           |
| amenable          | 〜に適している      |
| feed              | (ニューラルネットに、実データを)与える |
| unroll            | (RNNを)展開する    |
| truncate          | (余分なものを)切り取る |
| esoteric          | 難解な            |
| strawman          | たたき台          |

<hr/>

<a name="lecture4"></a>
## 講義4: 言語モデルとRNN パート2

講師：Phil Blunsom

RNN が Nグラム言語モデルよりも性能が良いのだとしたら、何か長距離の依存関係を捉えられているはずだ → しかし、本当に学習できているか？

- 消える（爆発する）勾配問題
    - 時間軸上をさかのぼる勾配に何が起きているか？
    - zn = 非線形関数の中身
    - Vh -> zn を直前の隠れ層 hn-1で偏微分
    - 誤差関数の h1 偏微分 -> Vh を何回も掛け合わせる
    - Vh のスペクトル半径 (固有値) は多くの場合、小さい -> 距離にしたがって勾配が指数関数的に小さくなる

- 解決策
    - ２階微分使う (例：LBFGS) (スケールしない)
    - 勾配が消えないような初期化をする
    - 根本的な解決策：アーキテクチャを変えてしまうこと！

- LSTM (Long Short Term Memory)
    - セル状態 cn (記憶) を導入
    - LSTM のキー：現在のセル状態 = f * 直前のセル状態 + 何か
        - 注：RNN のような掛け算ではなく、足し算
        - ここに非線型性を入れないのが重要
    - 何か -> i (入力ゲート) * tanh(入力; 直前の隠れ層)
    - f -> 忘却 (forget)
    - 実装：多くの線形変換をひとまとめにできる
    - 変種：i のかわりに (1 -f)

- Gated Recurrent Unit (GRU)
    - セル状態が無く、h だけ
    - "ゲート付き和セル (Gated additive cells)" は (初期化などを工夫しなくても)うまくいく
    - 機械翻訳、音声認識、音声合成はだいたい LSTM

- 深い RNN に基づく言語モデル
    - 縦方向に長くする -> 時刻 t で複数の隠れ層 (記憶が増える)
    - 横方向に長くする -> Recurrent Highway Network

- スケーリング
    - ニューラル言語モデルの計算量 -> 語彙のサイズに大きな影響を受ける
    - 特に最後の softmax 層
    - short-list → 高頻度語だけニューラルモデルを使う。他はn-gram -> ニューラルモデルの利点を殺してしまう
    - Batch local short-list -> バッチ内の語彙だけを使う。乱暴な近似＋不安定
    - 勾配を近似 -> softmax を exp で置き換え、分母を違うパラメータで置き換える
    - NCE (Noise Contrastive Estimation)
        - データが本当の分布から来ているかノイズのある分布から来ているかの二値分類器
        - 訓練時間を削減
        - テスト時には通常の softmax を計算するので、速くならない
    - Important Sampling (IS)
        - 本当の単語とノイズのあるサンプルの間の多値分類器
    - 要素に分解 (factorization)
        - Brown クラスタリング等を使ってクラスに分類
        - クラスの分布とクラス内の分布の２つの softmax に分解
        - 多層化 二分木 (バイナリコードを各単語に付与)
            - 短所：二分木を作るのが難しい  GPU で速くしにくい

- サブワードモデル
    - 単語のかわりに文字レベル
    - 中国語などは単語の概念がそもそも曖昧
    - softmax が速い, 未知語が無い (例：人名) かわりに、依存の距離が長くなる
    - 形態学的な単語内の構造を扱える 例：disunited, disinherited, disinterested
    - perplexity では単語レベルにはまだ敵わないが、言語モデルの未来

- 正規化
    - Dropout
        - 0/1 のビットマスクをサンプル、隠れユニットに乗算
        - リカレントな接続 (例：隠れ層間) に適用しても効果的ではない
            - 理由: 時間軸上でこれを繰り返すと、ある時間が経過すると全ての隠れ状態がマスクされてしまう
        - リカレントではない接続（例：入力→隠れ層) だけに Dropout を適用
        - よく採られる方法：過学習するほどネットワークを大きくし、強く正規化をかける

    - Bayesian Dropout
        - リカレントな接続間で共有される Dropout マスクを使う
        - 文ごとに違う重みを使う

| 英語              | 日本語             |
|-------------------|--------------------|
| compelling         | 魅力的な           |
| Finnish            | フィンランド語 (形態論が特に複雑なことで有名) |
| Turkish            | トルコ語           |
| hone in on         | ..に焦点をあわせる  |
| modus operandi     | 決まったやり方      |

<hr/>

<a name="lecture5"></a>
## 講義5: テキスト分類

講師：Karl Moritz Hermann (DeepMind)

- テキスト分類とは？
    - スパム分類
    - 記事のトピック
    - ツイートのハッシュタグ予測

- 分類の種類
    - 二値 (true/false)
    - 多値
    - 多ラベル
    - クラスタリング

- 分類の方法
    - 手動（正確だが遅い、高い）
    - ルールベース（正確だが、ルールを人手で書く必要がある）
    - 統計ベース（自動で高速だが、訓練データが必要）

- 統計的テキスト分類
    - P(c|d) (c ... クラス、d ... テキスト/文書)
    - 表現  テキスト -> d
    - 分類  P(c|d)

- 表現
    - BoW (bag-of-words)
    - 手動で作った素性
    - 素性学習

- 生成 vs 識別モデル
    - 生成モデル P(c, d) 潜在変数と観測変数の同時分布に確率を付与
        - Nグラム, 隠れマルコフモデル, 確率的文脈自由文法, etc.
    - 識別モデル P(c | d) データが与えられた時の潜在変数の分布に確率を付与
        - ロジスティック回帰

- ナイーブベイズ
    - ベイズの法則
    - P(c | d) 比例 P(c) P(d|c) -> 文書を単語に分解 P(c|t_i)
    - ラベル付きの訓練データの統計を取るだけ
    - 「ナイーブ」-> 全ての単語は独立　文書の確率を単語の確率の積で近似　実際はけっこううまくいく
    - MAP (maximize a posteriori)
    - 大量の小さい確率の積はトリッキー → 対数空間で計算
    - 確率ゼロ　→ スムージング
    - 長所：シンプル、解釈可能、速い
    - 短所：独立仮定、文・文書の構造を考慮してない、ゼロ確率
    - ナイーブベイズは生成モデル！

- 素性表現
    - 二値・多値・連続値

- ロジスティック回帰
    - ロジスティック：ロジスティック関数を使う　回帰：素性と重みの積で表現
    - 二値のケース  logit = バイアス＋重み*素性、P(true|d) = ロジスティック関数(logit)
    - 多値のケース  logit → softmax
    - softmax → ロジスティック関数の多値への拡張
    - 分類だけではなく確率も学習
    - 学習：対数確率を最大化  βに関する微分は凸関数　ただし閉じた解は存在しない
    - 長所：シンプル、解釈可能、素性間の独立を仮定しない　短所：学習が（ナイーブベイズより）難しい　手法をデザインする必要　汎化しない可能性

- RNN (再帰型ニューラルネットワーク)
    - hi は、i までの入力と、i - 1 までの h に依存
    - i までのテキストの情報を含んでいる
    - テキストの表現そのもの！
    - テキスト全体を読ませた後の h を取り出して素性にすればいい
    - h が必要な情報を含んでいることをどのように保証するか？
    - 損失関数：基本的には MLP (多層パーセプトロン) と同じ → クロスエントロピー
    - 多クラス分類
        - クロスエントロピーは、ラベルが1つの場合
        - 方法1: 複数の２値分類器を訓練
    - 複数の目的関数
        - 言語モデルの目的関数と文書分類を同時に最適化する
        - あらかじめ学習した単語の埋め込み表現を使うことも
    - 双方向RNN
        - 前向きRNNの最後の隠れ状態＋後ろ向きRNNの最後の隠れ状態
        - ただしテキスト生成には使えない
    - 生成モデルにも識別モデルにもなる

- 非系列型ニューラルネット
    - 再帰型ネット
        - 構文の形に潜在状態を構成
        - 自己複合器 (autoencoder) の損失関数を導入
    - 畳み込みネット
        - 畳み込み フィルタを適用
        - Subsample (maxなど)一部の画素だけを残す
        - 単語 x 埋め込み  の行列を元画像と見なす
        - 利点：速い、BOW で十分、行列（小さい窓）を使うので、構造を少し使える
        - 欠点：逐次的ではない、可変長のテキストに対する生成モデルは少し難しい

| 英語              | 日本語             |
|-------------------|--------------------|
| plagiarism        | 剽窃                |
| interpretable     | 解釈可能な           |
| reconstruction    | 再現                |

<hr/>

<a name="lecture6"></a>
## 講義6: Nvidia の GPU を使った深層学習

講師：Jeremy Appleyard (Nvidia)

- なぜ性能が重要か
    - 訓練時：より多くのアーキテクチャを実験できる
    - プロダクション：ユーザーにより速く結果を提示できる
    - 全てが自動ではない　機械学習の研究者も知っているべきこと

- ハードウェア
    - CPU → 遅延がなるべく小さいように最適化　大きなキャッシュ
    - GPU → 並列度が非常に高い。数万の演算を同時に実行　すぐにデータが帰ってこない
        - CPU より10倍以上高いスループット (gflops)
        - メモリー帯域も同じ傾向

- ルーフライン・モデル
    - 演算強度 (arithmetic intensity) = flop / バイト → x軸
    - 演算性能 flop/s → y軸
    - グラフにすると、屋根のような形になる → ルーフライン
    - 例：行列乗算　演算強度が高い

- RNN (LSTM)
    - 多くの行列乗算
    - ミニバッチ化  (収束が良くなる、ハードウェア上で高速化)
    - 行列乗算の右側 (w_t, h_t-1) は共通 → ４つの乗算を一つにまとめることが可能

- 行列x行列乗算 (GEMM - BLAS の関数名)
    - 計算省略
    - LSTM: flops / バイトの比は 2HB:3B+4H → O(n) だが、H と B の値に大きく依存
    - プロダクション：バッチサイズは 1 であることが多い
    - ルーフライン・モデル (バッチのサイズ 対 GFLOP/s)
    - バッチサイズ = 32 〜 64 あたりに「角」がある
    - 実測値と理論値はよく一致している（角のあたり以外）
    - ミニバッチ化は非常に大切！

- ネットワークレベルの最適化
    - どうやって結果を変えずに高速化するか
        - メモリー転送を減らす
        - オーバーヘッドを減らす
        - 並列度を上げる

- 最適化1 (メモリー転送)
    - 行列 A (固定) をメモリにロードする時間を削減
    - 入力 w_t はお互いに独立
    - W*[w_t; h_(t-1)] を、w に依存する部分と h に依存する部分の和に分解
    - w をグループ化  バッチサイズを増やすのと同等
    - 永続RNNs → リカレント行列を、チップ上のメモリに保持しておく高度テクニック

- 最適化2
    - オーバーヘッド
    - 要素ごとの積　各演算ごとにカーネルを起動
    - 演算ごとにカーネルを起動しなければいけない理由はない  

- 最適化3
    - 並列度を上げる
    - 多層RNN
    - 単純な方法：１層目をすべて計算、次に２層目をすべて計算、etc.
    - 代わりに、放射状に互いに依存しないセルを同時に計算する

- cuDNN
    - LSTM などの標準的な高速化が提供されている
    - BLAS, FFT, 乱数生成 などのライブラリも

- おわりに
    - 性能を意識することは大事
    - ソフトウェアとハードウェアの選択、両方が影響


| 英語              | 日本語             |
|-------------------|--------------------|
| bound             | 上限              |
| intensity         | 強度              |
| pointwise         | (本講義では)要素ごとの (element-wise と同じ)  |
| back-to-back      | 隣り合わせに       |

<hr/>

<a name="lecture7"></a>
## 講義7: 条件付き言語モデリング

講師：Chris Dyer (DeepMind / カーネギーメロン大)

- 条件「無し」の言語モデル
    - ある語彙上の文字列に対して確率を付与
    - 過去の履歴から次の単語を予測する問題に単純化

- 条件付き言語モデル
    - ある文脈条件 x のもと、言語を生成
        - x: 著者、w: その著者のテキスト
        - x: フランス語の文, w: 翻訳された英語の文 (確率が訳に立つ！)
        - x: 画像, w: 画像のキャプション
        - x: 音声, w: 音声の書き起こし
        - x: 文書＋質問, w: 応答
    - 訓練データは入力, 出力のペア
    - タスクによって、利用できるデータの量が大きく異る
        - 翻訳、要約、キャプション、音声認識等は比較的大規模なデータ

    - アルゴリズム
        - 最も確率の高い w を探すのは困難
        - ビームサーチ
    - 評価
        - クロスエントロピー, パープレキシティ (実装：普通、解釈：難しい)
        - タスク依存の評価  例：翻訳のBLEU（実装：簡単、解釈：普通） ←オススメ
        - 人手評価（実装：難しい、解釈：簡単）

- エンコーダー・デコーダーモデル
    - 入力 x を固定長ベクトル c にどうエンコード（符号化）するか → 問題依存
    - デコード時に、どうやって c を条件として使うか → あまり問題依存ではない

- Kalchbrenner and Blunsom 2013
    - デコーダー：古典的な RNN ＋ 原文をエンコードしたもの s
    - エンコーダー：単純なモデル：単語埋め込みの和
        - 利点：速い　データ量が少なくて済む
        - 欠点: 語順を考慮しない  非合成的な語 ("hot dog") を扱えない
    - もう少し賢いモデル：Convolutional sentence model (CSM)
        - 重ね合わせた畳み込み層
        - 利点：局所的な相互作用　構文的なものを捉えられる
        - 欠点：長さの異なる文をどう扱いか

- Sutskever et al. 2014
    - さらに単純な構造　エンコーダー・デコーダー両方 LSTM
    - エンコーディングは (c_l, h_l) (注：c → セル状態，h → 隠れ状態)
    - 利点：LSTM が長距離の依存関係を覚えられる  欠点：隠れ状態が多くの情報を覚えないといけない
    - 工夫
        - エンコーダとデコーダ間で文を与える順序を逆にする
        - アンサンブル  (Softmax の前に、複数個のモデルの出力を平均する)
    - デコーディング
        - arg max P(w | x) の arg max を正確に計算するのは難しい
        - 貪欲法で代替 直前の単語が正しいと仮定して次の単語に移る
        - ビームサーチ：上位 b 個の仮定を保持しながらデコード

- 画像キャプション生成
    - ニューラルネットは全てがベクトル → 複数のモダリティ (様式) に対応するのが簡単
    - ImageNet の訓練済みレイヤーを画像のエンベディングとして使用
    - Kiros et al. (2013)
        - 上述の K&B 2013 に類似
        - 隠れ状態の更新の際に、エンコードされた画像を足し合わせるだけ
        - 乗算的言語モデル テンソル r_(i, j, w) → 分解して低ランク近似

- 質問
    - 単語をどう翻訳するのは文脈依存ではないか？
        - Yes! だが、現在よく使われているテストセットでは文はかなり独立
        - 会話文のようなより良いテストデータでは効果があるかも


| 英語              | 日本語             |
|-------------------|--------------------|
| unconditional     | 無条件の/条件の無い   |
| conditional       | 条件付きの           |
| transcription     | (音声の) 書き起こし   |
| intractable       | 計算量的に困難       |
| modulo            | 〜を除いて          |
| modality          | 様式 (例：画像 vs テキスト) |
| architecture      | アーキテクチャ (ニューラルネットの構造) |
| compositional     | (意味が) 合成的な    |
| draconian         | 極めて厳しい         |

<hr/>

<a name="lecture8"></a>
## 講義8: アテンションを使った言語生成

講師：Chris Dyer (DeepMind / カーネギーメロン大)

復習：条件付き言語モデル

- 問題点
    - ベクトルによる条件付け → 文を固定長のベクトルに圧縮
    - 勾配を非常に長い距離、伝播させる必要がある  LSTM も忘れる

機械翻訳におけるアテンション

- 解法
    - 原言語の文を行列で表現 → 容量問題を解決
    - 対象言語の文を行列から生成 → 伝播問題を解決

- 文の行列表現
    - 行列の列の数 = 単語の数
    - 単純なモデル：単語ベクトルの連結（単純すぎて誰も論文に書いていない）
    - 畳み込みネット：Gehring et al. (2016)  K & B (2013) に似ている
    - 双方向RNN: Bahdanau et al. (2015) により有名
        - 前向き＋後ろ向き → 連結 →　行列 (2n x w)
    - 2017年の現状
        - 体系的に比較した研究はほとんど無い
        - 畳み込みネットは興味深く、あまり研究されてない

- 行列からの生成 (Bahdanau et al. 2015)
    - 生成時に、RNN は２つの情報を使う
        - 直前に生成した単語のベクトル表現
        - 入力行列の「ビュー」
            - 時間ごとに、入力行列の違う部分から情報を取り出す
            - 重み a_t (長さ = |f|) → アテンション
            - 各（生成側の）単語が（入力側の）単語にどう対応しているか解釈可能
        - どう a_t を計算するか
            - 各時刻 t に、期待される入力ベクトル r_t = V s_(t-1) を計算 (V は学習可能パラメータ)
            - → これを、F の各列との内積を計算 → Softmax して a_t を得る
            - (Bahdanau et al. 2015) → 内積を MLP で置き換え
    - BLEU +11!

- モデルの変種
    - Early binding (早期結合)
    - Late binding (晩期結合？) 現在の潜在状態と、アテンション・ベクトルを考慮して、単語を生成
        - 遅すぎる？ アテンションが間接的にしか潜在状態に寄与してない
        - 訓練時に、潜在状態とアテンションの計算を並列化できる

- まとめ
    - アテンションは畳み込みネットの「プーリング」に似てる
    - アテンションを可視化すると単語のアラインメントが観察できる
    - 勾配について
        - デコーダーが間違えた場合、アテンションの強い語に勾配が強く伝播する
    - 翻訳とアテンション
        - 人間が翻訳する時、文を記憶するわけではない → 必要に応じて原文を参照する

画像キャプション生成におけるアテンション

- Vinyals et al. 2014
    - Sutskever のモデルと同じ
    - ただし、画像のエンコーダーは畳み込みネット

- アテンションは役に立つか？
    - Yes!
    - 畳み込みネットの各知覚野を畳み込んだベクトル → アノテーション・ベクトル a
    - アテンションの重みを、Bahdanau et al. 2014 の方法で計算
    - Stochastic hard attention (Xu et al. 2015)
        - ソフトな分布ではなく、知覚野を一つに決めてサンプル
        - Jensen の不等式を使い単純化
        - MCMC を使いサンプリング
        - 教科学習の REINFORCE
        - アテンションの重み → 単語を生成した時にどこに注目していたかを可視化できる
        - BLEU を使って画像キャプションを評価するのは、機械翻訳に比べて難しい


| 英語              | 日本語              |
|-------------------|--------------------|
| vehemently        | 猛烈に              |
| Vulgar Latin      | 俗ラテン語          |
| receptive field   | 知覚野　　　　　　　　|
| inequality        | 不等式             |

<hr/>

<a name="lecture9"></a>
## 講義9: 音声認識

講師：Andrew Senior (DeepMind)

- 音声認識
    - ASR 自動音声認識  音声の波形→テキスト
    - TTS テキスト読み上げ  テキスト→音声の波形
    - 関連する問題
        - 自発発話 vs 読み上げ, 大規模語彙, 雑音のある環境, 低資源, 訛り, etc.
        - TTS
        - 話者特定
        - 音声強調
        - 音源分離

    - 音声
        - 気圧の変化の波
        - 声帯 → 声道による変調 → 調音（母音） ＋ 摩擦や閉鎖（子音）
    - 音声の表現
        - 人間の音声は ~85 Hz - 8 kHz
        - 解像度 (bits per sample) 1 bit でも理解可能
        - より低次元のデータ → 高速フーリエ解析 (FFT) して周波数帯ごとのエネルギーに変換
            - 音声の問題を画像認識の問題に変換！
            - ただし x軸（時間）は可変
        - FFT もまだ次元が多すぎる
            - メル尺度 (人間の聴力特性に合わせた非線型スケール) に変換した離散ウインドウを使ってダウンサンプリング
            - 40次元程度
        - MFCC (メル周波数ケプストラム係数)
            - メル尺度のフィルタバンクから得られた値を離散コサイン変換 (主成分分析に類似)
            - 連続するフレーム間で積み重ね
    - 音声認識の歴史
        - 1960年代：Dynamic Time Warping (テンプレートを伸縮してマッチング)
        - 1970年代：隠れマルコフモデル
        - 1995-：ガウス混合モデルが主流
        - 2006-：ニューラルネットワーク
        - 2012-：RNN
    - コミュニケーションとしての音声
        - 音素(phoneme) - 単語・意味を区別する最小の単位  表記：IPA/X-SAMPA
        - 韻律(prosody) - リズム、アクセント、イントネーションなど。認識する研究は多いが、あまり使われない
    - データセット
        - TIMIT (小さい、音素境界を人手で付与)
        - Wall Street Journal 読み上げ
        - ...
        - Google voice search
            - 実際のユーザーの発話
            - ２年間だけ保存、その後破棄
        - DeepSpeech
            - 発話者がヘッドフォンで雑音を聞きながら発話 → 発話に影響
            - その上に雑音を付与
    - 確率的音声認識
        - 入力 o (observation; 観察) から、 最も尤もらしい単語系列 w を求める。
        - HMM 状態＝音素、出力＝MFCCなどのベクトル
    - 音の単位
        - 文脈非依存のHMM 状態 (語頭・語中・語末の３状態を別々にモデル化)
        - 文脈依存のHMM 状態 (例: "cat" の /k/ と "cone" の /k/ が違う)
        - diphone (音素のバイグラム)
        - 音節
        - 単語全体 (YouTube 音声認識の論文)
        - graphemes (文字) - 単語→発音の辞書を持たなくても良い
            - 英語では普通  単語<->発音の対応を(音声認識の副作用として)学習  (例："ough")
            - 他の言語（イタリア語・トルコ語）では綴りが音に一致
    - 文脈依存の音素クラスタリング
        - 音素のトライグラムを考えると、3 x 42^3 の組み合わせ
        - このほとんどは起こらない → クラスタリング
    - 音声認識の基本式
        - w^ = arg max P(w | o) = arg max P(o | w)P(w)
        - P(o|w) ... 音響モデルスコア, P(w) ... 言語モデルスコア
        - 言語モデル chain rule を使った n-gram  デコーディング時に最ランキング
        - n-gram 言語モデルと LSTM等の識別的言語モデルを組み合わせると良い結果
    - 変換としての音声認識
        - 音声→フレーム→状態→音素→単語→文→意味
        - 重み付き有限状態トランスデューサー(WFST) (音素→単語への変換)
        - 単語→文へ変換する WFST と合成
    - ガウス混合モデル (音響モデル)
        - 1990〜2010 の主流モデル
        - 複数のガウス分布の重み付き和。各分布の平均と分散(対角成分のみ)を学習
        - EMアルゴリズムによって学習 M:強制アラインメント, E:パラメータの推定
        - とても並列化しやすいが、データを効率的に利用できない (1フレーム→1音素)
    - 強制アラインメント
        - ビタビアルゴリズムを使い、訓練データにおいて、素性と音素状態を最尤アラインメント
    - デコーディング
        - 認識時は、行列のかわりにグラフになる（語の間の空白、複数の可能性、etc.）
        - ビームサーチ (スコアの高い top-n 経路だけを残す)

- ニューラルネットワークを用いた音声認識
    - 素性を計算 or 確率を計算
    - 素性を計算
        - 通常の前向きネットワーク、ボトルネック層の値を素性と使う
        - 元のガウス混合モデルと合わせて（連結して）使う
    - ハイブリッド・ネット
        - 音素の分類器としてNNを学習
        - P(o | c) を GMM ではなくNNでモデル化
        - 言語モデルと音響モデルを重みで調整すると良い結果
    - 畳み込み式ネット (CNN)
        - 歴史は長い
        - WaveNet （音声合成）でも使われる
        - 時間軸上の pooling は良くない（時間情報を捨ててしまう）周波数の領域では OK
    - 繰り返し型ネット (RNN)
        - RNN, LSTM, ..
        - CLDNN (Sainath et al., 2015a) - CNN + LSTM + DNN
        - GRU (DeepSpeech)
        - 双方向モデルで性能は上がるが、遅延が生じる （発話の終わりまで待たないといけない）
        - テクニック：発話が終わったかどうか確信の無い段階で、Web検索を開始 → 低遅延を実現
        - Switchboard (大規模・電話・自発発話コーパス)で人間に匹敵 (Xiong et al., 2016)
            - BLSTMのアンサンブル
            - i-vector で話者を正規化
    - CTC (Connectionist Temporal Classification) → テクニックの集合
        - 音素の間に無音シンボルを挿入
        - 継続的アラインメント
    - Sequence discriminative training
        - Cross entropy は、正しいクラスの確率を最大化する
        - 本当に最小化したいのは WER (単語誤り率) → これと近い、微分可能な損失関数を使う
        - 訓練時にデコーディング(言語モデルを含む)をし、間違えた部分と正解との差を増やす
        - WER を 15％削減
    - seq2seq
        - 基本的な seq2seq は音声認識に向いてない　発話は長すぎる＋機械翻訳等と異なり、単調 (monotone)
        - アテンションは向いてる  Attention + seq2seq (Chorowski et al. 2015)
        - Listen, Attend, Spell (Chen et al., 2015)
        - 別々に学習した言語モデルを統合するのが難しい
        - Watch Listen, Attend, Spell (Chung et al., 2016) 音声認識＋ビデオから読唇  音声だけよりも良い。ビデオだけでも音声認識できる (WER = 15%)
        - Neural transducer - アテンションは系列全体を見なければならない。チャンク毎に認識することで解決

| 英語              | 日本語             |
|-------------------|--------------------|
| peculiarity       | 特異な点           |
| nominal           | 名目上の           |
| babble            | ガヤガヤという話し声 |
| Zulu              | ズールー語          |
| prosody           | 韻律              |
| acoustic          | 音響的な           |
| vocal tract       | 声道              |
| arbitrarily       | 任意に            |
| perceptive        | 知覚的な           |
| Polish [pouliʃ]   | ポーランド(人の/語) |
| polish [pɑliʃ]    | 磨く              |
| lexicon           | 辞書              |
| precursor         | 先駆け             |
| monotonic         | 単調              |

<hr/>

<a name="lecture10"></a>
## 講義10: 音声合成

講師：Andrew Senior (DeepMind)

音声認識（続き）

- End-to-end モデル
    - 生の音声データからテキストを出力するモデルを直接学習する
    - 音素の代わりに文字/単語を出力
    - 素性の計算を単純化　(MCFF/log-Mel などの人手で作られた素性に頼らない)
    - 依存関係の距離が長くなる
    - Clockwork RNN (Koutnik et al, 2014) 周期の異なる階層的な複数のRNN

- フィルタの学習
    - 特性周波数のピークを低い周波数から順にプロット
    - より低い周波数帯をカバーするフィルタが多い

- 雑音のある環境下での音声認識
     - ノイズを人工的に合成
     - Google では、YouTube のビデオからスピーチ以外の部分を抽出して合成
     - 部屋シミュレーター
     - denoiser (ノイズ除去器) をマルチタスク的に学習 → 文字書き起こしの無い音声データも使える
     - 雑音のある環境下では、人間の話し方も変わる

- 複数マイクの音声認識
     - 研究レベルでの歴史は長いが、スマホ、Amazon Echo などの複数マイクデバイスが普及するにつれて重要に
     - ビームフォーミング (Beamforming) マイクの指向性を高める

音声合成

- 音声合成とは
    - テキストから音声波形
    - 音声生成の過程
        - 声帯・声道 → 口で変調

- 音声生成の流れ
    1. テキスト解析
        - 例：文分割、単語分割、品詞解析、テキスト標準化, etc.
        - 例：429 は four-hundred-twenty-nine か four-twenty-nine か
        - 離散 → 離散的 (NLP)
    2. 音声生成
        - 離散 → 連続的

- 音声生成
    - ルールに基づいたフォルマント合成
    - サンプルに基づいた連結合成 → 途切れ途切れの音、不自然
    - フレーズ合成 (例：駅のアナウンス) → 「次の列車は」＋地名＋「行きです。」
    - モデルに基づいた生成的合成

- 連結合成
    - 多様性のあるデータベースを作成
    - diphones をカバー
    - 簡単な音声認識システムを使い、強制アラインメント → diphone の境界を特定
    - コスト（サンプルと望む出力の距離）を最小化

- データベースの作成
    - スタジオ録音
    - 一貫した環境
    - 背景雑音無し
    - プロの単一話者から大量のオーディオを録音
    - 読み上げ音声（自発発話ではない）
    - データセット
        - VCKT (Voice Cloning Tool Kit)
            - 退行性疾患患者が、あらかじめ自分の声を録音→話せなくなってからも自分の声で音声合成
            - 汎用的なモデルを訓練し、自分の声に適応
        - Merlin
            - オープンソースの音声合成システム

- 音声合成の評価
    - 音声認識は簡単 → 単語誤り率
    - 音声合成 → 主観的
    - 客観的な指標 (例: 駅のアナウンス)：聞いて分かるか？今ああまり意味をなさない
    - Mean Opinion Scale (0 から 5の尺度)
    - A/B 選好テスト どちらがより良いか
    - 客観的な指標
        - PESQ
        - ロバストな MOS
    - Blizzard Competition
        - 音声合成のコンペティション

- TTSの確率的な定式化
    - p(x | w, X, W)
        - X: 音声波形, W: 文字書き起こし, w: 入力テキスト, x: 出力波形
    - 補助変数
        - o: 音響素性, l: 言語素性, λ: モデル
    - 近似1：点推定
    - 近似2: ステップ毎の最大化
    - 言語的素性
        - 文 (長さ)、句 (抑揚)、単語 (品詞)、音節 (強調、声調)、音素 (有声/無声)
    - 持続時間モデル
        - 各音素がどのぐらいの時間継続するかを別にモデル化
    - Vocoder
        - voice decoder/encoder 声の合成

生成的音響モデル

- HMM
    - アラインメント・モデルと同様
    - 各状態に対して、出力ベクトルの平均・分散を計算、生成の際に利用する
    - 多くの情報が平均されているので、くぐもった声になる
    - 問題：
        - スムーズではない
        - 高次元の音響素性を扱いにくい
        - データの断片化
- ニューラルネット
    - ガウシアン分布の代わりにニューラルネットを使用
    - フレーム間で固定でなくても良い → よりスムーズな転移
    - 隠れ層にリカレント接続を入れると性能が向上
    - 高次元の素性をモデル化可能（生スペクトルさえ）
    - 現在では、研究＋製品の主流

- End-to-End システム
    - Audo-encoder を使い、低次元の音響素性を学習 → 良い結果
    - Source-filter モデルと音響モデルを同時に最適化
    - WaveNet
        - 生音声の生成モデル
        - Pixel RNN, Pixel CNN のモデルに類似
        - 自己回帰モデル
        - 畳み込みネットでモデル化 (Casual dilated convolution) 長距離の依存関係を捉えられる
        - 出力に softmax (回帰ではなく分類)
            - 単にサンプリングすると品質が落ちるので、μ-lawアルゴリズムを最初に適用
        - "Dan Jurafsky" 「今では、音声合成は言語モデルと同じ問題だ」
    - ベイジアン End-to-End
        - 積分をアンサンブルで近似
    - WaveNet ではじめて連結方式を超えた
        - 自然さやモデルの柔軟性では生成モデルのほうが連結方式よりも上

- 課題
    - 文脈依存性 → 答えになる単語を強調
    - 音声合成と音声認識を一つのシステムとして訓練


| 英語              | 日本語             |
|-------------------|--------------------|
| filterbank       | フィルタバンク (フィルタの集合) |
| modulate         | 変調する              |
| fricative        | 摩擦音                |
| click            | パチパチ音            |
| degenerative     | 退行性               |
| intelligible     | 理解できる            |
| muffled          | 音がくぐもった        |
| Houston          | ハウストン　(ニューヨークの通り) |
| Houston          | ヒューストン (テキサスの都市)  |

<hr/>

<a name="lecture11"></a>
## 講義11: 質問応答

講師：Karl Moritz Hermann (DeepMind)

- なぜ質問応答が重要か
    - 質問応答は AI 完全
        - QA が解ければ他の問題も解ける
    - 多くの応用 (検索、対話、情報抽出, ...)
    - 最近の良い結果 (例：IBM Watson Jeopardy!)
    - 多くの課題（比較的容易なものも含め）

- 質問応答は３種類のデータに依存
    - 質問
    - 文脈/ソース(出典)
    - 応答 (これ自体が質問であることも)

- 質問の分類
    - 5W1H
    - 質問の主語
    - 予測される応答の種類
    - 応答を引き出す出典の種類

- 「応答」にまず注目。QAシステムを作る際には
    - 応答はどういった形式か
    - どこから応答を引き出してくるか
    - 訓練データはどういった形式か

をまず考えるのが有用。

- 質問応答の種類
    - 読解理解
    - 意味解析
    - 画像質問応答
    - 情報検索
    - 図書参照

意味解析 (Semantic Parsing)

- 自然言語を意味の形式表現に変換 → 論理表現を使ってデータベースを検索
- 知識ベース
    - ３つ組で知識を格納 (関係, エンティティ1, エンティティ2)
    - 自由で利用可能な知識ベース (FreeBase, WikiData, etc.)
- 知識ベースは簡単に利用できるが、訓練データを入手するのは大変
    - 言語を論理表現に変換するための訓練を経た人しかできない (Amazon Mechanical Turk が使えない)

- 深層学習によるアプローチ
    - 機械翻訳と同じモデル（系列変換）
    - 問題点：訓練データが少ない、目的言語（論理表現）が複雑、固有名詞や数字の扱いが難しい
    - 解決策：論理表現に頼らない。論理表現を潜在的なものとして扱い、質問→応答を直接学習
    - 改善手法：アテンションを使う、目的言語側での制約を使う、半教師あり学習を使う
    - 複数のソースからの生成
        - "Pointer Networks" の利用
        - データベースを参照

読解理解

- 新聞記事＋質問（穴埋め形式） → 応答
- 大規模コーパス (CNN/DailyMail, CBT, SQuAD)
    - 前提：訓練時には出典を見ない、答えは出典の中に単語かフレーズの形で含まれる
- 固有名詞と OOV を匿名のマーカーに置換
    - 語彙サイズの削減、訓練したモデルの一般化
- ニューラルモデル：P(a|q, d) をモデル化
- d → 双方向 LSTM, q → 双方向 LSTM, 合成
- アテンションを利用した読解理解 → 時刻 t ごとの文書dの表現を求め、クエリ表現と合成
- Attention Sum Reader: 応答は文書の中に含まれているという事実を使い、答えが位置 i にある確率をそのままモデル化

応答文選択

- 質問に対し、応答として使える文をコーパス（ウェブ全体）選ぶ
- データセット：TREC QA Track, MS MARCO
- ニューラルモデル：応答候補 a クエリ q に対して、sigmoid(q^T M a + b) を計算
- 評価：精度、MRR (平均逆順位)、BLEU

画像QA

- データ・セット (VisualQA, VQA 2.0, COCO-QA)
- ニューラルモデル：質問→何らかのエンコーダ, 画像→畳み込みネット
- 「盲目モデル」（画像を見ない）でもそこそこ上手く行く
- 読解理解とタスクが似ている → アテンションのような同様のテクニックが使える

- まとめ：QAシステムのつくりかた
    - タスクは何か
    - 質問、応答、文脈はどんなものか
    - データはどこから来るか
    - データを補充できるか
    - 質問と文脈をどうエンコードするか
    - 質問と文脈をどう組み合わせるか
    - 答えをどう予測・生成するか

| 英語              | 日本語             |
|-------------------|--------------------|
| low hanging fruit | 簡単に解決できる問題  |
| MET office        | イギリス気象庁       |
| factoid           | (イギリス英語) 疑似事実 |
| defunct           | 機能していない       |
| grounded          | 基底的 (真偽値が求められる) |
| extrapolate       | 外挿する            |
| anonymize         | 匿名化する          |
| garbage in, garbage out  |  質の低い入力からは質の低い出力しか生まれないこと |

<hr/>

<a name="lecture12"></a>
## 講義12: 記憶

講師: Ed Grefenstette (DeepMind)

- RNN 復習
    - RNN 入力→出力 + 隠れ状態 ht -> ht+1 に更新
    - 長距離の依存を扱える
    - 多くのNLPタスクが、変換タスクとして捉えられる (構文解析、翻訳、計算)
        - Learning to Execute → Python プログラムを１文字ずつ読み込み、実行結果を１文字ずつ出力
            - 注：評価時に、「正しい」系列を入力して次の文字を予測。
    - 計算の階層
        - 有限状態機械（正規言語） → プッシュダウン・オートマトン (文脈自由言語) → チューリングマシン (計算可能な関数)

- 変換モデルのボトルネック
    - 容量が可変ではない
        - 原文の全ての情報を隠れ状態に保持しないといけない
        - 対象言語のモデリングに大部分の時間がかかる
        - エンコーダーに伝わる勾配が小さい

- RNNの限界
    - チューリングマシン → RNNに変換化　ただし学習可能とは限らない
    - 単純な RNN は、チューリングマシンを学習できない
    - RNN は、有限状態機械の近似
    - RNN の状態は、コントローラーと記憶両方の役割
    - 長距離の依存関係は、より大容量の記憶が必要
    - 有限状態機械は、そもそも限界がある

- RNN 再考
    - APIの視点から考える（前の状態＋入力 → 次の状態＋出力） vanilla RNN も LSTM も同じ
    - コントローラーと記憶を分ける

- アテンション
    - あるデータを表現するベクトルの配列
    - 入出力ロジックを制御するコントローラー
    - 各時刻で記憶を読む
    - 記憶に勾配を蓄積
    - Early Fusion vs Late Fusion → 記憶から読み込んだデータを入力に統合するか、出力に統合するか
    - エンコーダー・デコーダーモデルのためのROM
        - エンコーダーに勾配が別の経路で伝わる → ボトルネックの回避
        - ソフトアラインメントの学習
        - 長い系列の中で情報を見つけやすい
        - 記憶が固定
    - テキスト含意
        - Premise (前提) と Hypothesis (仮説) → 矛盾/中立/含意
        - 単純なモデル：前提＋仮説に RNN + アテンションを適用
        - 読解理解

- レジスタ機械
    - コントローラーが RAM に影響を及ぼす
    - コントローラーが（記憶アクセス用の）キーを生成 → アテンションのように使う
    - チューリングマシンとの関係：一般的なアルゴリズムを学習するのは難しいが、特定の条件下では可能 (e.g., Graves et al. 2014)
    - 複雑な推論には、RNN+アテンション以上に複雑で表現力の高いものが必要

- ニューラル・プッシュダウン・オートマトン
    - ニューラル・スタック
    - コントローラーが、push/pop動作 + データを決める
    - 連続値スタック  各ベクトル（データ）に確信度を付与。push/pop は確信度を加算/減算
    - 人工タスク：値のコピー、反転
    - 言語タスク：SVO から SOV への変換  性の無い言語から有る言語への変換
    - LSTM でも収束するが、学習が遅い（正規言語の近似を学習している）
    - Stack, Queue, DeQueue, それぞれ得意な問題が違う


| 英語              | 日本語             |
|-------------------|--------------------|
| esoteric          | 難解な            |
| with a grain of salt | 話半分に        |
| hierarchy         | 階層              |
| premise           | 前提              |
| hypothesis        | 仮説              |


<hr/>

<a name="lecture13"></a>
## 講義13: ニューラルネットにおける言語知識

講師: Chris Dyer

- 言語学とは
    - 言語でどう意味を表現するか
    - 脳がどう言語を処理・生成するか
    - 人間の言語にはどういうものが可能か
    - 人間の子供は、少ないデータからどう言語を学ぶか

- 文の階層関係
    - not と anybody の間にNPI (negative polarity item; 否定極性項目) の関係
    - "not" は anybody よりも先に来ないといけない (木の親)
    - 仮説: 子供が言語を簡単に学ぶのは、構造的にあきらかに意味をなさない仮説を考えていないから

- RNN
    - RNN は非常に強力なモデル
    - チューリング完全
    - どういった帰納的バイアスがあるか
    - どういった過程を置くか

- RNN の[帰納的バイアス](https://en.wikipedia.org/wiki/Inductive_bias)
    - 難しい問題
    - 系列的新近性を優先
    - 証拠：勾配、系列の反転などの実験、アテンション
    - チョムスキー「人間の言語を効率的に学ぶためには、系列的新近性は良いバイアスではない」

- 言語はどう意味を表現するか
    - "This film is hardly a treat."
    - 否定 "hardly" が入る
    - Bag-of-words モデルでは難しい
    - 系列的 RNN でもおそらくうまくいく
    - 合成の原則：表現の意味は、個別の構成要素の意味とそれを合成する規則から成る
    - 統語論の木表現 → 構文木

- 再帰的ニューラルネットワーク
    - 構文木の各節点に隠れ状態  h = tanh(W[l;r] + b) として再帰的に構成する
    - 節点の種類(動詞, 名詞, etc.)によって合成ルールを変える → W を変える
    - 映画のレビューを構文解析し、各節点について極性（ポジティブ、ネガティブ）をアノテート
    - 否定によって、極性がまったく変わってしまうことも
    - 精度を見ると、Bigram + ナイーブベイズより少し良いだけ
        - ただし、"not good" "not terrible" などの否定を伴う表現で非常に高精度
    - 多くの拡張
        - セルの定義、樹状LSTM、N個の子節点、プログラミング言語への応用
    - リカレント（繰り返し型）との比較
        - 利点：構文に従った意味の表現　良い帰納的バイアス　勾配の逆伝播距離が短い　中間節点へのアノテーション
        - 欠点：構文木が必要　右分岐した時勾配の伝播距離が長い　バッチ計算しにくい

- 構文解析
    - RNN 文法
    - RNN を使ってシンボル＋制御シンボルを生成
    - 木のトップダウン、左→右の表現を生成 (木のS式表現)
    - スタックにこれまでに生成されたシンボルを保持
    - 次のアクションの確率をどう求めるか
        - 長さに上限が無い → RNN
        - 部分木の複雑さに上限が無い → 再帰的ニューラルネット
        - 状態をあまり更新しない → stack RNN
    - スタックRNN
        - PUSH と POP の２つの演算
        - PUSH した時に前にあった要素との間に接続を作る → 接続が木構造と同じになる
    - 系列的新近性よりも構文の新近性を重視
    - パラメータ推定
        - 生成モデル p(x, y), 文 x と構文木 y
        - 識別モデル GEN のかわりに、SHIFT 操作を使う
    - 解析
        - ビームサーチを使う
        - 条件付きの言語モデル　アクション列の確率をモデリングしている
    - 結果
        - 生成モデルの方が良い。従来手法より高い F値
        - 言語モデルとして使うと LSTM+dropout より良い

- 単語の表現
    - 任意性
        - car - c + b = bar
        - cat - b + b = bat   (同じ演算なのに結果が全く違う)
    - 文字に意味はあるか？
        - cool   cooool   coooooool  ← 意味が予測できる
        - cat + s = cats,  bat + s = bats ← 規則的
    - 単語を構造のあるオブジェクトとして見る
        - 形態素解析し、形態素ごとのベクトルを合成
        - 1. 元のベクトル、2. 形態素ベクトルの合成、3. 文字ベクトルの合成、を連結
        - 複数の生成モードを混合し、単語を生成
        - トルコ語とフィンランド語での言語モデリング
            - モードが増えるほど、性能が向上

- ニューラルネットの言語概念の解析
    - [Lizen, Dupoux, Goldberg 2017](https://arxiv.org/pdf/1611.01368.pdf)
    - 言語モデリングの代わりに、数の一致を予測
    - Wikipedia の文を自動でアノテーション
    - 結果
        - 途中にはさまる名詞が無い場合 → 距離が14まで基本的にエラー率は 0
        - 途中にはさまる名詞の数に影響される (エラー率５%ほど)
    - 他の実験
        - 文法的か、非文法的か
        - 言語モデリングを目的関数とした場合、うまくいかない。構文を一般的に学習しているわけではない
        - 文法チェッカーを作る場合は注意！（文法を直接学習させたほうが良い）

- まとめ
    - 言語学の利点：より良いモデルが作れる　モデルがきちんと動いているか調べられる


| 英語              | 日本語             |
|-------------------|--------------------|
| empirical         | 経験的な            |
| constituent       | 構成要素            |
| parse             | 構文木, 構文解析結果  |
| idiosyncratic     | 独特の              |
| confound          | 交絡                |
